{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\ndigital_out_a = DigitalOut(brain.three_wire_port.a)\nrotation_8 = Rotation(Ports.PORT8, True)\ndistance_15 = Distance(Ports.PORT15)\nrotation_9 = Rotation(Ports.PORT9, False)\ninertial_7 = Inertial(Ports.PORT7)\ndigital_out_d = DigitalOut(brain.three_wire_port.d)\nrotation_11 = Rotation(Ports.PORT11, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n#endregion VEXcode Generated Robot Configuration\n# ---------------------------------------------------------------------------- #\n#                                                                              #\n# \tModule:       main.py                                                      #\n# \tAuthor:       Aryan                                                        #\n# \tCreated:      11/21/2024, 12:22:13 PM                                       #\n# \tDescription:  V5 project                                                   #\n#                                                                              #\n# ---------------------------------------------------------------------------- #\n\n# Library imports\nfrom vex import *\n\n\n\nbrain = Brain()\n\nlimit_down = Limit(brain.three_wire_port.h)\n\nclamp = DigitalOut(brain.three_wire_port.a)\n\nbelt = Motor(Ports.PORT9, GearSetting.RATIO_18_1, False)\n\nStage1 = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\n\nlift = Motor(Ports.PORT8, GearSetting.RATIO_36_1, True)\n\nrotation_belt = rotation_8.position(TURNS)\n\ndoinker = DigitalOut(brain.three_wire_port.d)\n\nring_sensor = distance_15.object_distance(MM)\n\n#stops belt and intake\ndef stopDurAuto():\n    left_motor_1.stop()\n    left_motor_2.stop()\n    left_motor_3.stop()\n    right_motor_1.stop()\n    right_motor_2.stop()\n    right_motor_3.stop()\n\ndef intake_spin():\n    Stage1.set_velocity(100, PERCENT)\n    Stage1.spin(FORWARD)\n    belt.set_velocity(100, PERCENT)\n    belt.spin(FORWARD)\ndef intake_reverse():\n    Stage1.set_velocity(100)\n    Stage1.spin(REVERSE)\n    belt.set_velocity(100)\n    belt.spin(REVERSE)\ndef intake_stop():\n    Stage1.stop()\n    belt.stop()\n\n\n\n# Define motors for the drivetrain\nleft_motor_1 = Motor(Ports.PORT1, GearSetting.RATIO_36_1, False)  # Adjust port and reversal as needed\nleft_motor_2 = Motor(Ports.PORT2, GearSetting.RATIO_36_1, False)\nleft_motor_3 = Motor(Ports.PORT3, GearSetting.RATIO_36_1, True)\n\nright_motor_1 = Motor(Ports.PORT4, GearSetting.RATIO_36_1, True)  # Adjust port and reversal as needed\nright_motor_2 = Motor(Ports.PORT5, GearSetting.RATIO_36_1, False)\nright_motor_3 = Motor(Ports.PORT6, GearSetting.RATIO_36_1, True)\n\n# Define the controller\ncontroller = Controller(ControllerType.PRIMARY)\n\ndef pid_control(target_position, kp, ki, kd):\n    integral = 0\n    last_error = 0\n    tolerance = 0.1  # Allowable error range for stopping\n    max_output = 50  # Maximum motor speed (%)\n    min_output = 5   # Minimum motor speed (%)\n\n    while True:\n        # Get current position (normalize to [0, 360))\n        current_position = rotation_11.position(DEGREES) % 360\n\n        # Map positions to the range [0, 3]\n        if current_position > 3:\n            current_position -= 360\n        current_position = max(0, min(3, current_position))\n        target_position = max(0, min(3, target_position))\n\n        # Calculate the error\n        error = target_position - current_position\n\n        # Check if the error is within tolerance\n        if abs(error) <= tolerance:\n            # Forcefully stop the motor\n            lift.set_velocity(0, PERCENT)\n            lift.stop(BRAKE)\n            break\n\n        # Calculate integral and derivative terms\n        integral += error\n        derivative = error - last_error\n\n        # Compute PID output\n        output = (kp * error) + (ki * integral) + (kd * derivative)\n\n        # Clamp output to ensure movement\n        if abs(output) < min_output:\n            output = min_output if output > 0 else -min_output\n        output = max(min(output, max_output), -max_output)\n\n        # Apply motor command\n        if output > 0:\n            lift.set_velocity(output, PERCENT)\n            lift.spin(FORWARD)\n        elif output < 0:\n            lift.set_velocity(abs(output), PERCENT)\n            lift.spin(REVERSE)\n\n        # Update the last error\n        last_error = error\n\n        # Wait to prevent loop overload\n        wait(20, MSEC)\n\ndef lift_pid_control(setpoint, kp, ki, kd):\n    integral = 0\n    last_error = 0\n    tolerance = 0.5  # Tolerance for stopping\n    max_output = 100  # Max motor speed (%)\n    min_output = 5    # Min motor speed (%)\n\n    while True:\n        # Get current lift position\n        current_position = rotation_11.position(DEGREES)\n\n        # Calculate error\n        error = setpoint - current_position\n\n        # Check if within the acceptable range\n        if abs(error) <= tolerance:\n            lift.stop(BRAKE)\n            break\n\n        # Calculate integral and derivative\n        integral += error\n        derivative = error - last_error\n\n        # Calculate PID output\n        output = (kp * error) + (ki * integral) + (kd * derivative)\n\n        # Clamp output to avoid too little or excessive power\n        if abs(output) < min_output:\n            output = min_output if output > 0 else -min_output\n        output = max(min(output, max_output), -max_output)\n\n        # Apply power to the lift\n        if output > 0:\n            lift.set_velocity(output, PERCENT)\n            lift.spin(FORWARD)\n        else:\n            lift.set_velocity(-output, PERCENT)\n            lift.spin(REVERSE)\n\n        # Update the last error for the next loop\n        last_error = error\n\n        # Add a small delay to prevent loop overload\n        wait(20, MSEC)\n\n\n\n\n\n\n\ndef turn_90(direction):\n\n    wait(0.5,SECONDS)\n\n    if direction == 'left':\n        left_motor_1.spin(REVERSE, 80, PERCENT)\n        left_motor_2.spin(REVERSE, 80, PERCENT)\n        left_motor_3.spin(REVERSE, 80, PERCENT)\n  \n  \n        right_motor_1.spin(FORWARD, 50, PERCENT)\n        right_motor_2.spin(FORWARD, 50, PERCENT)\n        right_motor_3.spin(FORWARD, 50, PERCENT)\n\n\n    if direction == 'right':\n        left_motor_1.spin(FORWARD, 50, PERCENT)\n        left_motor_2.spin(FORWARD, 50, PERCENT)\n        left_motor_3.spin(FORWARD, 50, PERCENT)\n  \n  \n        right_motor_1.spin(REVERSE, 80, PERCENT)\n        right_motor_2.spin(REVERSE, 80, PERCENT)\n        right_motor_3.spin(REVERSE, 80, PERCENT)\n\n    wait(0.305, SECONDS)\n\n    stopDurAuto()\n\ndef autonomous():\n\n   lift.spin_for(FORWARD, 0.5, TURNS, wait=False)\n   clamp.set(False)\n   brain.screen.clear_screen()\n   brain.screen.print(\"Autonomous Mode\")\n  \n\n   # Drive forward for 2 seconds\n   left_motor_1.spin(FORWARD, 50, PERCENT)\n   left_motor_2.spin(FORWARD, 50, PERCENT)\n   left_motor_3.spin(FORWARD, 50, PERCENT)\n  \n   right_motor_1.spin(FORWARD, 50, PERCENT)\n   right_motor_2.spin(FORWARD, 50, PERCENT)\n   right_motor_3.spin(FORWARD, 50, PERCENT)\n  \n   wait(1, SECONDS)  # Wait for 2 seconds while motors run\n  \n   # Stop all motors\n   left_motor_1.stop()\n   left_motor_2.stop()\n   left_motor_3.stop()\n   right_motor_1.stop()\n   right_motor_2.stop()\n   right_motor_3.stop()\n\n    # Clamp onto the Mobile Goal\n\n   clamp.set(True)\n\n\n   wait(1, SECONDS)\n   Stage1.set_velocity(100, PERCENT)\n   belt.set_velocity(100, PERCENT)\n   Stage1.spin(FORWARD)\n   belt.spin(FORWARD)\n\n\n\n\n   wait(1, SECONDS)\n\n    # Turn negative 40 degrees to align to the stack of goals\n   left_motor_1.spin(REVERSE, 80, PERCENT)\n   left_motor_2.spin(REVERSE, 80, PERCENT)\n   left_motor_3.spin(REVERSE, 80, PERCENT)\n  \n  \n   right_motor_1.spin(FORWARD, 50, PERCENT)\n   right_motor_2.spin(FORWARD, 50, PERCENT)\n   right_motor_3.spin(FORWARD, 50, PERCENT)\n\n\n   wait(0.2, SECONDS)\n\n\n   stopDurAuto()\n  \n    # run into the stack to score the bottom ring\n\n   left_motor_1.spin(REVERSE, 50, PERCENT)\n   left_motor_2.spin(REVERSE, 50, PERCENT)\n   left_motor_3.spin(REVERSE, 50, PERCENT)\n  \n   right_motor_1.spin(REVERSE, 50, PERCENT)\n   right_motor_2.spin(REVERSE, 50, PERCENT)\n   right_motor_3.spin(REVERSE, 50, PERCENT)\n\n\n   wait(0.75, SECONDS)\n\n\n   stopDurAuto()\n\n   \n\n   \n   turn_90('left')\n\n\n   # Operate the clamp (open or close)\n\n   \n     # Example: Close the clamp\n     # Wait for 1 second\n\n\n   left_motor_1.spin(REVERSE, 25, PERCENT)\n   left_motor_2.spin(REVERSE, 25, PERCENT)\n   left_motor_3.spin(REVERSE, 25, PERCENT)\n  \n   right_motor_1.spin(REVERSE, 25, PERCENT)\n   right_motor_2.spin(REVERSE, 25, PERCENT)\n   right_motor_3.spin(REVERSE, 25, PERCENT)\n  \n   wait(1, SECONDS)  # Wait for 2 seconds while motors run\n  \n   # Stop all motors\n   left_motor_1.stop()\n   left_motor_2.stop()\n   left_motor_3.stop()\n   right_motor_1.stop()\n   right_motor_2.stop()\n   right_motor_3.stop()\n   \n\n   left_motor_1.spin(FORWARD, 50, PERCENT)\n   left_motor_2.spin(FORWARD, 50, PERCENT)\n   left_motor_3.spin(FORWARD, 50, PERCENT)\n  \n   right_motor_1.spin(FORWARD, 50, PERCENT)\n   right_motor_2.spin(FORWARD, 50, PERCENT)\n   right_motor_3.spin(FORWARD, 50, PERCENT)\n  \n   wait(0.4, SECONDS)  # Wait for 2 seconds while motors run\n\n   stopDurAuto()\n\n   left_motor_1.spin(REVERSE, 50, PERCENT)\n   left_motor_2.spin(REVERSE, 50, PERCENT)\n   left_motor_3.spin(REVERSE, 50, PERCENT)\n  \n   right_motor_1.spin(FORWARD, 80, PERCENT)\n   right_motor_2.spin(FORWARD, 80, PERCENT)\n   right_motor_3.spin(FORWARD, 80, PERCENT)\n  \n   wait(0.35, SECONDS)  # Wait for 2 seconds while motors run\n    \n   stopDurAuto()\n\n\n   left_motor_1.spin(REVERSE, 50, PERCENT)\n   left_motor_2.spin(REVERSE, 50, PERCENT)\n   left_motor_3.spin(REVERSE, 50, PERCENT)\n  \n   right_motor_1.spin(REVERSE, 50, PERCENT)\n   right_motor_2.spin(REVERSE, 50, PERCENT)\n   right_motor_3.spin(REVERSE, 50, PERCENT)\n\n\n   wait(0.9, SECONDS)\n\n\n   stopDurAuto()\n\ndef user_control():\n    brain.screen.clear_screen()\n    brain.screen.print(\"driver control\")\n    # Place driver control in this while loop\n\n    while True:\n        clamp_down = True\n        Doinker = False\n        # Get joystick values from the left stick\n        forward = -controller.axis3.position()  # Inverted forward/backward\n        turn = -controller.axis4.position()     # Inverted left/right\n        \n        # Calculate motor speeds\n        left_speed = forward + turn\n        right_speed = forward - turn\n\n        # Set motor speeds for the left side\n        left_motor_1.spin(DirectionType.FORWARD, left_speed, VelocityUnits.PERCENT)\n        left_motor_2.spin(DirectionType.FORWARD, left_speed, VelocityUnits.PERCENT)\n        left_motor_3.spin(DirectionType.FORWARD, left_speed, VelocityUnits.PERCENT)\n\n        # Set motor speeds for the right side\n        right_motor_1.spin(DirectionType.FORWARD, right_speed, VelocityUnits.PERCENT)\n        right_motor_2.spin(DirectionType.FORWARD, right_speed, VelocityUnits.PERCENT)\n        right_motor_3.spin(DirectionType.FORWARD, right_speed, VelocityUnits.PERCENT)\n\n        if(controller.buttonA.pressing()):\n            clamp_down = False\n\n        if(controller.buttonR2.pressing()):\n            intake_spin()\n\n        if(controller.buttonX.pressing()):\n            intake_reverse()\n        if(controller.buttonY.pressing()):\n            intake_stop()\n\n        \n\n        clamp.set(clamp_down)\n\n        lift_vel = controller.axis2.position()\n        lift.set_velocity(lift_vel)\n        lift.spin(REVERSE)\n        lift.set_stopping(HOLD)\n\n        if(controller.buttonUp.pressing()):\n            belt.set_velocity(75)\n            lift_pid_control(20, 0.5, 0.01, 0.1)\n\n                \n        \n        if(controller.buttonRight.pressing()):\n            doinker.set(True)\n        elif(controller.buttonDown.pressing()):\n            doinker.set(False)\n\n        # Small delay to avoid CPU overload\n        wait(20, MSEC)\n\n# Create competition instance\ncomp = Competition(user_control, autonomous)\n\n# Actions to do when the program starts\nbrain.screen.clear_screen()\n\n# Create competition instance\ncomp = Competition(user_control, autonomous)\n\n# Actions to do when the program starts\nbrain.screen.clear_screen()","textLanguage":"python","robotConfig":[{"port":[1],"name":"digital_out_a","customName":false,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[8],"name":"rotation_8","customName":false,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"true"},"triportSourcePort":22},{"port":[15],"name":"distance_15","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[9],"name":"rotation_9","customName":false,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false"},"triportSourcePort":22},{"port":[7],"name":"inertial_7","customName":false,"deviceType":"Inertial","deviceClass":"inertial","setting":{},"triportSourcePort":22},{"port":[4],"name":"digital_out_d","customName":false,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[11],"name":"rotation_11","customName":false,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.5","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}